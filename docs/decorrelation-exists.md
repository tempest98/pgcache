# Correlated Subquery Decorrelation for Update Queries

## Context

pgcache's CDC invalidation relies on **update queries** — per-table queries that check if a changed row affects a cached result. These are generated by `query_table_update_queries()` which walks `select_nodes_with_source()` to extract table branches.

Currently, `select_nodes_with_source()` splits correlated subqueries into separate branches:
```
SELECT e.* FROM employees e WHERE EXISTS (SELECT 1 FROM orders o WHERE o.emp_id = e.id)

Branch 0: outer SELECT → Direct        → tables: [employees]
Branch 1: inner SELECT → Subquery(Inclusion) → tables: [orders]
```

This breaks because Branch 1's update query references `e.id` from the outer scope — CDC can't evaluate it independently.

## Approach: One Branch Per Correlated Query

**Principle**: All tables participating in a correlated subquery belong to the same branch. Decorrelation flattens the correlation into JOINs, and `select_nodes_with_source()` naturally sees one unified branch:

```
-- After decorrelation:
SELECT DISTINCT e.* FROM employees e JOIN orders o ON o.emp_id = e.id

Branch 0: SELECT → Direct → tables: [employees, orders]   ← one branch, both tables
```

Decorrelation only affects update query generation. The main cached query (for population/serving) stays as-is — PostgreSQL handles correlation natively.

## Transformations

**EXISTS → INNER JOIN + DISTINCT (semi-join):**
```sql
-- Original (stays as cached query for population/serving):
SELECT e.* FROM employees e
WHERE EXISTS (SELECT 1 FROM orders o WHERE o.emp_id = e.id AND o.status = 'active')

-- Decorrelated form (for update query generation only):
SELECT DISTINCT e.* FROM employees e
JOIN orders o ON o.emp_id = e.id
WHERE o.status = 'active'
```

Both `employees` and `orders` appear as direct JOIN participants → both get `Direct` source → CDC generates update queries for both from the same branch.

**NOT EXISTS → LEFT JOIN + IS NULL (anti-join):**
```sql
-- Original:
SELECT d.* FROM departments d
WHERE NOT EXISTS (SELECT 1 FROM employees e WHERE e.dept_id = d.id)

-- Decorrelated form:
SELECT d.* FROM departments d
LEFT JOIN employees e ON e.dept_id = d.id
WHERE e.dept_id IS NULL
```

`departments` is on the preserved side → `Direct`. `employees` is on the optional side → `OuterJoinTerminal` / `OuterJoinOptional` (LEFT JOIN semantics preserved by existing outer-join classification in `query_table_update_queries`).

## New File: `src/query/decorrelate.rs`

### Types

```rust
error_set! {
    DecorrelateError := {
        #[display("Non-decorrelatable correlated subquery: {reason}")]
        NonDecorrelatable { reason: String },
    }
}
pub type DecorrelateResult<T> = Result<T, Report<DecorrelateError>>;

pub struct DecorrelateOutcome {
    pub query: QueryExpr,
    pub resolved: ResolvedQueryExpr,
    pub transformed: bool,
}

struct CorrelationPredicate {
    outer_column: ColumnNode,  // column from outer scope
    inner_column: ColumnNode,  // column from subquery scope
}
```

### Functions (implementation order)

1. **Reuse `where_expr_conjuncts_split` and `where_expr_conjuncts_join` from `pushdown.rs`**
   These already exist and operate on `ResolvedWhereExpr`:
   - `where_expr_conjuncts_split(expr) -> Vec<ResolvedWhereExpr>` — flattens AND-chain into conjuncts
   - `where_expr_conjuncts_join(conjuncts) -> Option<ResolvedWhereExpr>` — rebuilds AND-chain from list
   Make them `pub(crate)` instead of creating new duplicates.

2. **`outer_ref_table_names_collect(&[ResolvedColumnNode]) -> HashSet<String>`**
   Extract outer table names/aliases from resolved outer_refs. Uses `table_alias` if present, falls back to `table`.

4. **`where_clause_correlation_partition(&WhereExpr, &HashSet<String>) -> Option<(Vec<CorrelationPredicate>, Option<WhereExpr>)>`**
   Split subquery WHERE into correlation predicates and residual predicates.
   - Correlation predicate = `Binary(Equal, Column(outer_table.col), Column(inner_table.col))`
   - Returns `None` if any correlation predicate is non-equality (unsupported)
   - Returns `(predicates, residual_where)` on success

5. **`subquery_exists_decorrelate(&SelectNode, &WhereExpr::Subquery, &[CorrelationPredicate], Option<WhereExpr>) -> SelectNode`**
   EXISTS → INNER JOIN + DISTINCT.
   - Builds `JoinNode { join_type: Inner, left: outer FROM, right: inner FROM, condition: correlation_predicates }`
   - Sets `distinct = true`
   - Residual inner predicates → merged into outer WHERE

6. **`subquery_not_exists_decorrelate(&SelectNode, &WhereExpr::Subquery, &[CorrelationPredicate], Option<WhereExpr>) -> SelectNode`**
   NOT EXISTS → LEFT JOIN + IS NULL.
   - Builds `JoinNode { join_type: Left, left: outer FROM, right: inner FROM, condition: correlation_predicates AND residual }`
   - Residual inner predicates go into ON clause (not outer WHERE — LEFT JOIN semantics require this)
   - Adds `UnaryExpr { op: IsNull, expr: Column(inner_correlation_column) }` to outer WHERE

7. **`select_node_decorrelate(&SelectNode, &ResolvedSelectNode) -> DecorrelateResult<SelectNode>`**
   Main entry point. Walks WHERE clause AND-conjuncts alongside resolved counterpart:
   - For each conjunct, check resolved form for `Subquery { outer_refs: [non-empty], .. }`
   - EXISTS with equality correlation → `subquery_exists_decorrelate`
   - `Unary(Not, Subquery(Exists))` with equality → `subquery_not_exists_decorrelate`
   - Any other correlated pattern → `Err(NonDecorrelatable)`
   - Also scans resolved SELECT columns and HAVING for non-empty `outer_refs` → reject if found
   - Returns original SelectNode unchanged if no correlated subqueries found

8. **`query_expr_decorrelate(&QueryExpr, &ResolvedQueryExpr, &BiHashMap<TableMetadata>, &[&str]) -> DecorrelateResult<DecorrelateOutcome>`**
   Top-level entry. Handles the full QueryExpr:
   - For `QueryBody::Select`: calls `select_node_decorrelate`, re-resolves if transformed
   - For `QueryBody::SetOp`: recursively handles each branch
   - Returns `DecorrelateOutcome { query, resolved, transformed }`

### Parallel walk strategy

The resolved and unresolved WHERE clause trees have identical structure (same branching at AND/OR/Unary nodes). Walk both in lockstep:
- `WhereExpr::Binary(And)` + `ResolvedWhereExpr::Binary(And)` → recurse both sides
- `WhereExpr::Subquery { .. }` + `ResolvedWhereExpr::Subquery { outer_refs, .. }` → check outer_refs
- `WhereExpr::Unary(Not, Subquery)` + `ResolvedWhereExpr::Unary(Not, Subquery)` → check NOT EXISTS

### NOT EXISTS residual predicate placement (critical subtlety)

For NOT EXISTS, non-correlation predicates go into the JOIN ON clause:
```sql
-- Correct: residual in ON
LEFT JOIN employees e ON e.dept_id = d.id AND e.status = 'active'
WHERE e.dept_id IS NULL

-- WRONG: residual in outer WHERE (always false since e.status is NULL when no match)
LEFT JOIN employees e ON e.dept_id = d.id
WHERE e.dept_id IS NULL AND e.status = 'active'
```

## Modified Files

### `src/query/mod.rs`
Add `pub mod decorrelate;`

### `src/cache/mod.rs`
Add `DecorrelateError` to error set:
```rust
QueryResolutionError := {
    ResolveError(ResolveError),
    DecorrelateError(DecorrelateError),
}
```

### `src/cache/writer/query.rs` (lines 121-174)
Insert decorrelation between resolution and update query generation:

```rust
// Existing: resolve the base query
let resolved = query_expr_resolve(&base_query, ...)...;

// NEW: Decorrelate correlated subqueries so all correlated tables
// appear as direct JOINs in a single branch. This is used ONLY for
// update query generation — population/serving use the original form.
let decorrelated = query_expr_decorrelate(
    &base_query, &resolved, &self.cache.tables, search_path
).map_err(|e| e.context_transform(CacheError::from))
 .attach_loc("decorrelating correlated subqueries")?;

let update_cacheable = CacheableQuery { query: decorrelated.query.clone() };
let update_resolved = &decorrelated.resolved;

// CHANGED: use decorrelated form for update queries.
// select_nodes_with_source() now sees JOINs instead of correlated subqueries,
// so all correlated tables land in one branch with proper Direct/OuterJoin sources.
for (table_node, update_query_expr, source) in
    query_table_update_queries(&update_cacheable, update_resolved)
{ ... }

// UNCHANGED: CachedQuery stores original base_query and resolved
let cached_query = CachedQuery {
    query: base_query,      // original, for population
    resolved: resolved,     // original, for serving
    ...
};
```

**Why this works**: `query_table_update_queries()` calls `select_nodes_with_source()` on the decorrelated form. Since EXISTS became INNER JOIN and NOT EXISTS became LEFT JOIN, both outer and inner tables appear as direct table nodes in a single branch. The existing `outer_join_optional_tables()` classification then correctly assigns `OuterJoinTerminal`/`OuterJoinOptional` for LEFT JOIN tables. No changes needed to `query_table_update_queries()` or `select_nodes_with_source()` themselves.

## Edge Cases

| Case | Handling |
|------|----------|
| No correlated subqueries | `DecorrelateOutcome { transformed: false }` → use originals as-is |
| Multiple EXISTS in AND | Each decorrelated independently, accumulating JOINs |
| EXISTS inside OR | Non-decorrelatable → reject query |
| Multiple correlation predicates | All go to JOIN ON as AND-chain |
| Subquery with its own JOINs | Inner FROM tree lifted as-is into right side of new JOIN |
| Outer query already has JOINs | Existing JOIN tree becomes left side of new JOIN |
| Correlated IN / scalar / ALL | Non-decorrelatable → `Err(NonDecorrelatable)` |
| Correlated subquery in SELECT list | Detected via resolved outer_refs → reject |
| Correlated subquery in HAVING | Detected via resolved outer_refs → reject |
| Mixed correlated + non-correlated subqueries | Correlated ones decorrelated; non-correlated left as subqueries |

## Tests

In `src/query/decorrelate.rs` `mod tests`:

**No-op cases:**
- Non-correlated EXISTS subquery → no transformation
- Query with no subqueries → no transformation

**EXISTS decorrelation (parse → decorrelate → deparse → verify structure):**
- Single-table EXISTS with single correlation equality
- EXISTS with multiple correlation equalities → multi-predicate ON
- EXISTS with mixed correlation + residual predicates
- EXISTS where outer query already has JOINs
- EXISTS with subquery that has inner JOINs
- Multiple EXISTS in same WHERE (AND-connected)
- EXISTS sets DISTINCT on result

**NOT EXISTS decorrelation:**
- Single-table NOT EXISTS
- NOT EXISTS with residual predicates → residual goes in ON clause
- NOT EXISTS adds IS NULL check to outer WHERE

**Rejection cases:**
- Correlated EXISTS with non-equality predicate (e.g., `>`)
- Correlated IN subquery
- Correlated scalar subquery in WHERE
- Correlated subquery in SELECT list
- EXISTS inside OR → rejected

**Integration test approach:** Use same `test_tables()` helper from `transform.rs` tests. Parse SQL, resolve, decorrelate, verify deparsed output matches expected JOIN form.

## Verification

1. `cargo check` — compiles
2. `cargo test` — all existing tests pass
3. `cargo test decorrelate` — new tests pass
4. `cargo clippy -- -D warnings` — no warnings
